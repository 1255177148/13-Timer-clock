#include <Atmel/REGX52.H>

/*
 * 定时器0初始化
 */
void Timer0Init() // 1毫秒@11.0592MHz
{
    /*
    TMOD寄存器是设置定时器模式的，可以将指定的【定时器/计数器】设置为计数器或者定时器，
    并指定该【定时器/计数器】是13位、16位、还是8位自动装载定时器，这里我们一般用16位。
    TMOD是不可位寻址，也就是只能整体赋值，不能单独指定给第几位赋值。
    TMOD结构如下：从高位到低位，也就是7到0
    GETE  C/T  M1  M0  GETE  C/T  M1  M0
    前4位控制【定时器/计数器】1 的模式，后4位控制【定时器/计数器】0 的模式
    */
    // TMOD = 1;    //设置定时器模式
    TMOD &= 0xF0; // 这里我们设置定时器0，所以为了不影响定时器1，我们先和1111 0000 进行与操作，低四位清零，高四位不变
    TMOD |= 0x01; // 这里我们和 0000 0001进行或操作，设置定时器模式
    /*
    （2^16– X）× 12 ÷ 晶振频率 = 定时时间（默认单位us），
    这里使用的单片机的晶振频率是11.0592MHZ，
    那么就是（2^16– X）× 12 ÷ 11.0592 = 定时时间（默认单位us），
    这里最大的定时时间就是当 X 为0时的，即2^16 × 12 ÷ 11.0592 = 71 us，
    那么这里我们设置定时时间为5us,则X为60928，16进制是 0xEE00
    */
    TL0 = 0x00; //设置定时初始值，低8位
    TH0 = 0xEE; //设置定时初始值，高8位
    TF0 = 0;    //清除TF0标志，当TH0、TL0溢出时，硬件会将TF0赋为1，然后向CPU请求中断，CPU相应中断后，TF0再由硬件赋为0
    TR0 = 1;    //定时器0开始计时
    /*
    下面是设置定时器0的中断线路处于打开状态
    */
    ET0 = 1;
    EA  = 1;
    PT0 = 0; //优先级为低，1为高
}

// /*
//  * 定制器0的中断函数，当定时器0溢出时，执行此函数
//  */
// void Timer0_Routine() interrupt 1
// {
//     static unsigned int t0Count;
//     TL0 = 0x00; //设置定时初始值，低8位
//     TH0 = 0xEE; //设置定时初始值，高8位
//     t0Count++;
//     if (t0Count >= 100) {
//         t0Count = 0;
//         if (ledModel == 0)
//         {
//             P2 = _crol_(P2, 1);// 自带函数，循环左移指定位数
//         } else
//         {
//             P2 = _cror_(P2, 1);// 自带函数，循环右移指定位数
//         }
        
        
//     }
// }